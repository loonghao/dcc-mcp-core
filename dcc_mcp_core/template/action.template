"""{{ description }}

Generated by DCC-MCP-Core action template generator.
"""

# Import built-in modules
from typing import Any, Dict, List, Optional, Union, ClassVar

# Import third-party modules
from pydantic import BaseModel, Field

# Import DCC-MCP-Core modules
from dcc_mcp_core.actions.base import Action
from dcc_mcp_core.models import ActionResultModel
from dcc_mcp_core.utils.type_wrappers import BaseWrapper


{% for func in functions %}
class {{ func.name|capitalize }}Action(Action):
    """{{ func.description }}

    This action provides functionality to {{ func.description|lower }}.
    """

    # Metadata
    name: ClassVar[str] = "{{ func.name }}"
    description: ClassVar[str] = "{{ func.description }}"
    version: ClassVar[str] = "0.1.0"
    author: ClassVar[str] = "{{ author }}"
    order: ClassVar[int] = 0
    tags: ClassVar[List[str]] = ["{{ func.name }}"]
    dcc: ClassVar[str] = "{{ dcc_name }}" 

    # Input parameters model
    class InputModel(Action.InputModel):
        """Input parameters for {{ func.name }} action."""
        {% for param in func.parameters %}
        {{ param.name }}: {{ param.type }}{% if param.default is not none %}{% if param.default is string %} = Field('{{ param.default }}', description="{{ param.description }}"){% else %} = Field({{ param.default }}, description="{{ param.description }}"){% endif %}{% else %} = Field(description="{{ param.description }}"){% endif %}
        {% endfor %}

        # Example of parameter validation
        # @field_validator('parameter_name')
        # def validate_parameter(cls, v):
        #     if not valid_condition:
        #         raise ValueError("Validation error message")
        #     return v

        # Example of parameter dependencies
        # @model_validator(mode='after')
        # def validate_dependencies(self, info):
        #     if self.param_a and not self.param_b:
        #         raise ValueError("If param_a is provided, param_b must also be provided")
        #     return self

    # Output model
    class OutputModel(Action.OutputModel):
        """Output data for {{ func.name }} action."""
        # Define your output fields here
        # Example:
        # result: Any = Field(description="Result of the operation")
        # created_items: List[str] = Field(default_factory=list, description="List of created items")

        # You can also include a prompt for the AI
        prompt: Optional[str] = Field(
            "What would you like to do next?",
            description="Suggestion for AI about next steps"
        )

    def _setup_context(self) -> None:
        """Set up additional context and dependencies.

        This method is called during the setup phase to prepare any
        resources or dependencies needed for execution.
        """
        # Get DCC client in multiple ways
        
        # 1. Directly from context
        self.dcc_client = self.context.get("{{ dcc_name }}_client")
        
        # 2. Try from action_bridge
        if not self.dcc_client:
            action_bridge = self.context.get("action_bridge")
            if action_bridge:
                self.dcc_client = getattr(action_bridge, "{{ dcc_name }}_client", None)
        
        # 3. Log warning instead of directly raising an exception, add flexibility
        if not self.dcc_client:
            self.logger.warning("{{ dcc_name|capitalize }} client not found in context, some functionality may be limited")

    def _execute(self) -> None:
        """Execute the action with validated parameters.

        This method implements the actual functionality of the action.
        It uses self.input for input parameters and sets self.output with an
        instance of OutputModel to provide structured output data.
        """
        try:
            # TODO: Implement your action logic here
            # Example implementation:

            # Access and process input parameters
            {% for param in func.parameters %}
            {{ param.name }} = self.input.{{ param.name }}
            # Process parameter value if needed (useful for string to native type conversion)
            {{ param.name }} = self.process_parameter_value({{ param.name }})
            # Wrap value for RPyC transmission if needed
            # {{ param.name }}_wrapped = BaseWrapper({{ param.name }})
            {% endfor %}

            # Perform the action using the DCC client
            # result = self.dcc_client.some_operation(params)

            # Set the output
            self.output = self.OutputModel(
                # Set your output fields here
                # Example:
                # result=result,
                prompt="Action completed successfully. What would you like to do next?"
            )
        except Exception as e:
            # Let the exception propagate to be handled by the process method
            # which will create an appropriate ActionResultModel with the error
            raise
{% endfor %}
